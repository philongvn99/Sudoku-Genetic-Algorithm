import numpy as np
from random import randint, sample, seed
from copy import deepcopy
import random

class Sudoku(object):

    ######################################## INITIALIZATION ######################################################

    def __init__(self, name, squareRoot_edge, population_size):
        
        #Initialize properties of Sudoku board
        self.name = name                                #   Name of Sudoku Object
        self.squareRoot_edge = squareRoot_edge          #   Square root (sqrt) of board's edge
        self.edge = squareRoot_edge * squareRoot_edge   #   Length of Edge
        self.population_size = population_size          #   Number of sub Table

   
    def numOfMissing(self, listObject):
        #   Find number or fail item in a list (item appear more than 1 time)
        #   Create a N-sized list of n number 1 (N = edge)
        #   If number appear 1 time, corresponding value in list is convert to 0. 
        #   In next times, sumMissing variable is increase by 1
        #   Argument:
        #       listObject: list for processing
        sumMissing = 0
        checkBoard = [1 for i in range(self.edge)]
        for digit in listObject:
            if checkBoard[digit-1]:
                checkBoard[digit-1] = 0
            else:
                sumMissing += 1
        return sumMissing

    def fitnessFunc(self, board):
        #   Calculate and return value of Fitness Function of a board
        #   Argument:
        #       board: puzzle board for processing
        totalMissing = 0

        #   Calculate and add sum of sumOfMissing of Rows to totalMissing
        totalMissing += sum([self.numOfMissing(row) for row in board])
        
        #   Calculate and add sum of sumOfMissing of Columns to totalMissing
        totalMissing += sum([self.numOfMissing(col) for col in zip(*board)])

        #   Calculate sum of sumOfMissing of Squares
        for index in range(self.edge):
            se = self.squareRoot_edge
            firstRow = (index // se) * se
            firstCol = (index % se) *se 
            # Add all times of each square to a list
            tempArray = [board[firstRow + x][firstCol + y] for x in range(se) for y in range(se)]
            # Then calculating and add to totalMissing
            totalMissing += self.numOfMissing(tempArray)

        return totalMissing

    def generateGoalBoard(self):
        n = self.squareRoot_edge
        se = self.edge
        
        # Generate root Row for root Goal Board
        rootRow = sample(range(1, n*n + 1), n*n)
        print(rootRow)

        # Root Goal Board is generated by slide rootRow properly
        rootGoalBoard = [[ rootRow[((r % n)*n +  r//n + s) % se ] for s in range(n*n)] for r in range(n*n)]
        pretty_print(rootGoalBoard      )
        # Generate 2 array to mutate root Goal Board
        rows = [r*n + s for r in sample(range(n), n) for s in sample(range(n), n)]
        cols = [c*n + s for c in sample(range(n), n) for s in sample(range(n), n)]

        # Generate goal Board
        self.goalBoard = [[rootGoalBoard[r][c] for c in cols] for r in rows]
        pretty_print(self.goalBoard)

        
    def generatePuzzleBoard(self):
        se = self.edge

        # Generte removal map
        #   number of blank cell is define three-fourth of edge total cell
        numOfRemoval = (se * se * 3) // 4 
        #   generate a list of removal positions
        removalPositions = sample(range(se * se), numOfRemoval)

        puzzleBoard = deepcopy(self.goalBoard)
        #   create a initial removal
        removalBoard = [[0 for i in range(se)] for i in range(se)]

        # correspondingly assign to puzzle and removal board for each removal position
        for pos in removalPositions:
            puzzleBoard[pos // se][pos % se] = 0    # assign 0 for Puzzle board
            removalBoard[pos // se][pos % se] = 1   # assign 1 for removal one
        self.puzzleBoard = puzzleBoard
        pretty_print(puzzleBoard)
        self.removalBoard = removalBoard
        # self.puzzleBoardList = [puzzleBoard for i in range(self.population_size)]
    
    def generateBoardList(self):
        #   Generate List of Board with size population_size
        #       Initailize an empty list
        puzzle_board_list = []
        #       Add (append) deepcopy of puzzle board
        #       Deepcopy: create a copy not relating to other copy of sample
        for _ in range(self.population_size):
            puzzle_board_list.append(deepcopy(sudokuObject.puzzleBoard)) 
        #       Replace blank cell with random 1-9 value
        for puzzleID, puzzleVal in enumerate(puzzle_board_list):
            for rowID, rowVal in enumerate(puzzleVal):
                row = rowVal
                for index, value in enumerate(row):
                    if value == 0:
                        row[index] = randint(1, self.edge)
                puzzle_board_list[puzzleID][rowID] = row
        self.puzzleBoardList = puzzle_board_list
        #       Show sub Boards
        for puzzle in self.puzzleBoardList:
            pretty_print(puzzle)

    def check_square(self, board, row, col):
        base = self.squareRoot_edge
        # check errors in the row
        row_errors = self.numOfMissing(board[row])
        # check errors in the column
        xboard = np.array(board)
        column_errors = self.numOfMissing(xboard[:, col])
        # check errors in the box
        box_list = []
        mul_row = row // base
        mul_col = col // base
        for i in range(0, base):
            for j in range(0, base):
                row_idx = (col + j) % base + base * mul_col
                col_idx = (row + i) % base + base * mul_row
                box_list.append(board[row_idx][col_idx])
        box_errors = self.numOfMissing(box_list)
        return (row_errors + column_errors + box_errors) == 0
    
    def executeCrossover(self):
        # Crossover action:
        #       Random a not-removal cell firstly
        #       Step-by-step select 2 sub Boards has most Fitness function value and do:
        #           +   swap row, col accross the cell is selected
        #           +   note to check list (convert to 0) 2 boards has been processed
        board_list = self.puzzleBoardList
        board_size = len(board_list[0])

        fitness_values = [self.fitnessFunc(board) for board in board_list]

        while sum(fitness_values) > 0:
            most_fit_idx = fitness_values.index(min(x for x in fitness_values if x > 0))
            fitness_values[most_fit_idx] = 0
            next_most_fit_idx = fitness_values.index(min(x for x in fitness_values if x > 0))
            fitness_values[next_most_fit_idx] = 0
            
            # select a position to crossover
            vertical = randint(1, board_size-1)                                                             # row index
            horizontal = random.choice([i for i, n in enumerate(self.removalBoard[vertical]) if n == 1])    # column index
            for row in range(self.edge):
                for col in range(self.edge):

                    n = board_list[next_most_fit_idx][vertical][col]
                    m = board_list[most_fit_idx][vertical][col]
                    board_list[next_most_fit_idx][vertical][col], board_list[most_fit_idx][vertical][col] = m, n

                    q = board_list[next_most_fit_idx][row][horizontal]
                    p = board_list[most_fit_idx][row][horizontal]
                    board_list[next_most_fit_idx][vertical][horizontal], board_list[most_fit_idx][vertical][horizontal] = p, q            
        self.puzzleBoardList = board_list

    def executeMutation(self):

        # Mutation action:
        #       Random a not-removal cell firstly
        #       For each sub Boards, do:
        #           +   find which digit has appeared in row, col and square accross the selected cell
        #           +   if no digit left (has not appeared) in checklist, replace selected cell by next value (1 by 2, ... , 9 by 1)
        #           #       else replace by poped value from check list

        sse = self.squareRoot_edge
        se = self.edge
        #   random cell
        vertical = randint(0, se-1)                                                                     # row index
        horizontal = random.choice([i for i, n in enumerate(self.removalBoard[vertical]) if n == 1])    # column index
        puzzle_list = self.puzzleBoardList
        # Assign selectedCol for checkSquare of Mutation

        boardCandiadates = []

        # Iterate List of Boards
        for index, puzzle in enumerate(puzzle_list):
            # generate check list with N value 1-N (n = edge)
            notYetAppearance = sample(range(1, se + 1), se)
            selectedCell = puzzle[vertical][horizontal]
            notYetAppearance.extend((selectedCell, selectedCell, selectedCell))

            for i in range(self.edge):
                #   Checking through row
                if puzzle[vertical][i] in notYetAppearance:
                    notYetAppearance.remove(puzzle[vertical][i])
                #   Checking through column
                if puzzle[i][horizontal] in notYetAppearance:
                    notYetAppearance.remove(puzzle[i][horizontal])

            #   use div method to get most-left and most-high cell of square containing selected cell
            firstRow = (vertical // sse) * sse
            firstCol = (horizontal // sse) * sse
            #   iterate through square for checking it
            for row in range(sse):
                for col in range(sse):
                    val = puzzle[row + firstRow][col + firstCol]
                    if val in notYetAppearance:
                        notYetAppearance.remove(val)
            if(notYetAppearance != []):
                if(len(notYetAppearance) == 1):
                    boardCandiadates.append(index)
                self.puzzleBoardList[index][vertical][horizontal] = notYetAppearance.pop()
            else:
                x = self.puzzleBoardList[index][vertical][horizontal]
                self.puzzleBoardList[index][vertical][horizontal] = (x % se) + 1
       
        if(boardCandiadates != []):
            selectedBoard = boardCandiadates.pop()
            if self.check_square(selectedBoard, vertical, horizontal):
                for board in self.puzzleBoardList:
                    board[vertical][horizontal] = selectedBoard[vertical][horizontal]



    def getBestFitness(self):
        # Get best Fitness function values (minimun)
        return min([self.fitnessFunc(puzzleBoard) for puzzleBoard in self.puzzleBoardList])

    def getBestBoard(self):
        # Get Board having best Fitness function values 
        fitnesses = [self.fitnessFunc(puzzleBoard) for puzzleBoard in self.puzzleBoardList]
        return self.puzzleBoardList[fitnesses.index(min(fitnesses))]

def pretty_print(board):
    #   A method i got from Github to display more visually
    #   But actually it's much efficient
    side = len(board)
    base = int(side ** 0.5)
    expand_line = lambda line : line[0]+line[5:9].join([line[1:5]*(base-1)]*base)+line[9:13]
    line0 = expand_line("I===========I")
    line1 = expand_line("I . | . I . I")
    line2 = expand_line("I---|---I---I")
    line3 = expand_line("I===|===I===I")
    line4 = expand_line("I===========I")
    symbol = " 1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    nums = [[""] + [symbol[n] for n in row] for row in board]
    print(line0)
    for r in range(1, side + 1):
        print("".join(n + s for n, s in zip(nums[r - 1], line1.split("."))))
        print([line2, line3, line4][(r % side == 0) + (r % base == 0)])


############################### START PROGRAM ###########################################
#   generate a Sudoku Object
sudokuObject = Sudoku('philong', 2, 4)

#   generate Goal Board and display it
sudokuObject.generateGoalBoard()
pretty_print(sudokuObject.goalBoard)

#   generate Puzzle Board (goal board with blank cells) and display it
sudokuObject.generatePuzzleBoard()

#   generate list of boards and display it
sudokuObject.generateBoardList()
pretty_print(sudokuObject.puzzleBoard)

#   time of loops
time = 0

#   overall minimum Fitness Function value (maximum value is 180 so we initialize it 181)
overalMin = 181

#   loop until get a sub Board has coresponding Fitness function result = 0
# for i in range (3):
while sudokuObject.getBestFitness() > 0:
    #   execute Crossover firstly in loop
    sudokuObject.executeCrossover()

    #   next execute Mutation
    sudokuObject.executeMutation()

    #   get best FF result among sub Boards's
    bestFitness = sudokuObject.getBestFitness()
    if overalMin > bestFitness:
        overalMin = bestFitness

    #   show result of each loop [time] : [immediate best FF result] - [overall minimum FF result]
    #   print(str(time) + ' : ' + str(bestFitness) + ' - ' + str(overalMin))
    
    #   incrase time variable by 1
    time += 1

# #   Loop is terminated if finding solution (subBoard with FF result = 0)
# #   get that Board by getBestBoard function
solution = sudokuObject.getBestBoard()

#   display solution
pretty_print(solution)

#   compare to initailized goal board
pretty_print(sudokuObject.goalBoard)

#   compare to initailized goal board
pretty_print(sudokuObject.puzzleBoard)

print(time)